<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Member List</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt; Member List</h1>This is the complete list of members for <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>, including all inherited members.<p><table>
  <tr bgcolor="#f0f0f0"><td><b>allocator_type</b> typedef (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>begin</b>() (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>begin</b>() const  (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#36bcd50fd5383f3682032323b2d74333">clear</a>()</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#342582ba05d9fb893ed80875d2b7a42f">concurrent_hash_map</a>(const allocator_type &amp;a=allocator_type())</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#bc50f7bca65d0c27cbf5c31d2fa63eac">concurrent_hash_map</a>(const concurrent_hash_map &amp;table, const allocator_type &amp;a=allocator_type())</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#b5132202dff9ee3d619bef6b1d84edea">concurrent_hash_map</a>(I first, I last, const allocator_type &amp;a=allocator_type())</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>const_accessor</b> (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [friend]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>const_iterator</b> typedef (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>const_pointer</b> typedef (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>const_range_type</b> typedef (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>const_reference</b> typedef (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#a3e97a1f3cb66e81a2336b013ef1ae7d">count</a>(const Key &amp;key) const </td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>delete_node</b>(node_base *n) (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline, protected]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>difference_type</b> typedef (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#3e5d085375320cd3f34faeedc5bba8f6">empty</a>() const </td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>end</b>() (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>end</b>() const  (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>equal_range</b>(const Key &amp;key) (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>equal_range</b>(const Key &amp;key) const  (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#58df7a1e4373c55eb4c2fa9dc69516b1">erase</a>(const Key &amp;key)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#fc64086f9f518cef8c368c9429d0064e">erase</a>(const_accessor &amp;item_accessor)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#b65abfa291da566617dd58dfb349630a">erase</a>(accessor &amp;item_accessor)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#671965989ffb5f6084c776cb0bb6cdab">exclude</a>(const_accessor &amp;item_accessor, bool readonly)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [protected]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#9fa1ca60af4ef761a100617b27718585">find</a>(const_accessor &amp;result, const Key &amp;key) const </td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#4f7cc0aab2d8216c0a6e681f32dd48c8">find</a>(accessor &amp;result, const Key &amp;key)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#2f1ca7e8319c464349a9de304b6dbf4a">find</a>(const Key &amp;key) const </td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline, protected]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#79d1e5c3b975dbd38b43138266fe4c0e">get_allocator</a>() const </td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#67d8c254b1666d89267c8a4a33c864f3">insert</a>(const_accessor &amp;result, const Key &amp;key)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#8ea81ff7fea044f859273b354c91c185">insert</a>(accessor &amp;result, const Key &amp;key)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#68a46a26bd4308c1780d021ca7e8fc15">insert</a>(const_accessor &amp;result, const value_type &amp;value)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#7bd4dcf6ea74a32299fd57d8d7fc7ed8">insert</a>(accessor &amp;result, const value_type &amp;value)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#3034a308bc839695a5714a107380c4b9">insert</a>(const value_type &amp;value)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#7b42dba04d71e1367f0d542087906178">insert</a>(I first, I last)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>internal::hash_map_iterator</b> (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [friend]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>internal::hash_map_range</b> (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [friend]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#7973cd92f57dcb092ab757f8d9e089f9">internal_copy</a>(const concurrent_hash_map &amp;source)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [protected]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>internal_copy</b>(I first, I last) (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [protected]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#308ec5ad19fdd1be4d345f8013070150">internal_equal_range</a>(const Key &amp;key, I end) const </td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [protected]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>iterator</b> typedef (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>key_type</b> typedef (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#0f0ba43d9cb783f12dd01bf5677da097">lookup</a>(bool op_insert, const Key &amp;key, const T *t, const_accessor *result, bool write)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [protected]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>mapped_type</b> typedef (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#6ed260e217fb310050928d7bd03f1b5e">max_size</a>() const </td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>my_allocator</b> (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [protected]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>my_hash_compare</b> (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [protected]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>node_allocator_type</b> typedef (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [protected]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#adadeb9d1acb8c3b34517435666cf297">operator=</a>(const concurrent_hash_map &amp;table)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>pointer</b> typedef (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>range</b>(size_type grainsize=1) (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>range</b>(size_type grainsize=1) const  (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>range_type</b> typedef (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>reference</b> typedef (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>rehash_bucket</b>(bucket *b_new, const hashcode_t h) (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline, protected]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>search_bucket</b>(const key_type &amp;key, bucket *b) const  (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline, protected]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#25b0e3881038877604c5efc1c14c4afd">size</a>() const </td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>size_type</b> typedef (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#dd73f70aa6602021ea2c56bac9715353">swap</a>(concurrent_hash_map &amp;table)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><b>value_type</b> typedef (defined in <a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a>)</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="a00130.html#5e96649f71f68f3b6bf3b1eee6b441a7">~concurrent_hash_map</a>()</td><td><a class="el" href="a00130.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</a></td><td><code> [inline]</code></td></tr>
</table><hr>
<p></p>
Copyright &copy; 2005-2009 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
