<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>tbb Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li id="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="namespaces.html"><span>Namespace List</span></a></li>
    <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
  </ul></div>
<h1>tbb Namespace Reference</h1>The namespace tbb contains all components of the library.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html">aligned_space</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block of space aligned sufficiently to construct an array T with N elements.  <a href="a00116.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html">atomic</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Primary template for atomic.  <a href="a00117.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00118.html">atomic&lt; void * &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for <a class="el" href="a00118.html">atomic&lt;void*&gt;</a>, for sake of not allowing arithmetic or operator-&gt;.  <a href="a00118.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html">blocked_range</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A range over which to iterate.  <a href="a00122.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html">blocked_range2d</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A 2-dimensional range that models the Range concept.  <a href="a00123.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00124.html">blocked_range3d</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A 3-dimensional range that models the Range concept.  <a href="a00124.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00125.html">cache_aligned_allocator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5.  <a href="a00125.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00126.html">cache_aligned_allocator&lt; void &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00126.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html">combinable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread-local storage with optional reduction.  <a href="a00128.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html">tbb_hash_compare</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">hash_compare - default argument  <a href="a00174.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html">concurrent_hash_map</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unordered map from Key to T.  <a href="a00130.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html">concurrent_bounded_queue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A high-performance thread-safe blocking concurrent bounded queue.  <a href="a00129.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00136.html">concurrent_vector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concurrent vector container.  <a href="a00136.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html">enumerable_thread_specific</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The thread local class template.  <a href="a00138.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>flattened2d</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00142.html">mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper around the platform's native reader-writer lock.  <a href="a00142.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html">null_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A mutex which does nothing.  <a href="a00144.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00146.html">null_rw_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A rw mutex which does nothing.  <a href="a00146.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html">parallel_do_feeder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class the user supplied algorithm body uses to add new tasks.  <a href="a00148.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00151.html">pre_scan_tag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to indicate that the initial scan is being performed.  <a href="a00151.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00140.html">final_scan_tag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to indicate that the final scan is being performed.  <a href="a00140.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00149.html">parallel_while</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over a stream, with optional addition of more work.  <a href="a00149.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00160.html">simple_partitioner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A simple partitioner.  <a href="a00160.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html">auto_partitioner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An auto partitioner.  <a href="a00120.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html">affinity_partitioner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An affinity partitioner.  <a href="a00115.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00139.html">filter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A stage in a pipeline.  <a href="a00139.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00175.html">thread_bound_filter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A stage in a pipeline served by a user thread.  <a href="a00175.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00150.html">pipeline</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A processing pipeling that applies filters to items.  <a href="a00150.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html">queuing_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queuing lock with local-only spinning.  <a href="a00152.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00154.html">queuing_rw_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reader-writer lock with local-only spinning.  <a href="a00154.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html">recursive_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mutex that allows recursive mutex acquisition.  <a href="a00156.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00158.html">scalable_allocator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5.  <a href="a00158.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00159.html">scalable_allocator&lt; void &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00159.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00161.html">spin_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A lock that occupies a single byte.  <a href="a00161.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00163.html">spin_rw_mutex_v3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast, unfair, spinning reader-writer lock with backoff and writer-preference.  <a href="a00163.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html">task_group_context</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to form groups of tasks.  <a href="a00167.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html">task</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for user-defined tasks.  <a href="a00166.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html">empty_task</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">task that does nothing. Useful for synchronization.  <a href="a00137.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html">task_list</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A list of children.  <a href="a00168.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>task_handle</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>task_group</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>missing_wait</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>structured_task_group</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html">task_scheduler_init</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class representing reference to tbb scheduler.  <a href="a00169.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00170.html">tbb_allocator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5.  <a href="a00170.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html">tbb_allocator&lt; void &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00171.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html">zero_allocator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5.  <a href="a00179.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00180.html">zero_allocator&lt; void, Allocator &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00180.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00121.html">bad_last_alloc</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception for concurrent containers.  <a href="a00121.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00172.html">tbb_exception</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface to be implemented by all exceptions TBB recognizes and propagates across the threads.  <a href="a00172.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html">captured_exception</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is used by TBB to propagate information about unhandled exceptions into the root thread.  <a href="a00127.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00141.html">movable_exception</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Template that can be used to implement exception that transfers arbitrary ExceptionData to the root thread.  <a href="a00141.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00165.html">split</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dummy type that distinguishes splitting constructor from copy constructor.  <a href="a00165.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html">tick_count</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Absolute timestamp.  <a href="a00176.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00232.html">strict_ppl</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>parallel_do</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="parallel_do_body_req.html">parallel_do Body</a>. <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g3383e2703977012b6f384d673410f1f7"></a><!-- doxytag: member="tbb::parallel_do" ref="g3383e2703977012b6f384d673410f1f7" args="(Iterator first, Iterator last, const Body &amp;body)" -->
template&lt;typename Iterator, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#g3383e2703977012b6f384d673410f1f7">parallel_do</a> (Iterator first, Iterator last, const Body &amp;body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over a range, with optional addition of more work. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g2617dc9b88b3285a7212599d49f74228"></a><!-- doxytag: member="tbb::parallel_do" ref="g2617dc9b88b3285a7212599d49f74228" args="(Iterator first, Iterator last, const Body &amp;body, task_group_context &amp;context)" -->
template&lt;typename Iterator, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#g2617dc9b88b3285a7212599d49f74228">parallel_do</a> (Iterator first, Iterator last, const Body &amp;body, <a class="el" href="a00167.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over a range, with optional addition of more work and user-supplied context. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_for</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="range_req.html">Range</a> and <a class="el" href="parallel_for_body_req.html">parallel_for Body</a>. <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g68cc046ef72c42ce205fccbc435a0d81"></a><!-- doxytag: member="tbb::parallel_for" ref="g68cc046ef72c42ce205fccbc435a0d81" args="(const Range &amp;range, const Body &amp;body)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#g68cc046ef72c42ce205fccbc435a0d81">parallel_for</a> (const Range &amp;range, const Body &amp;body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with default partitioner. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g13cac5dd55c7533bccea43a51c33d0e5"></a><!-- doxytag: member="tbb::parallel_for" ref="g13cac5dd55c7533bccea43a51c33d0e5" args="(const Range &amp;range, const Body &amp;body, const simple_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#g13cac5dd55c7533bccea43a51c33d0e5">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00160.html">simple_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with simple partitioner. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga7ac75d532389b55b9247f3fdb0b00d1"></a><!-- doxytag: member="tbb::parallel_for" ref="ga7ac75d532389b55b9247f3fdb0b00d1" args="(const Range &amp;range, const Body &amp;body, const auto_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#ga7ac75d532389b55b9247f3fdb0b00d1">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00120.html">auto_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00120.html">auto_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g9cd1b210ceb1c040f30e390b4a21bde8"></a><!-- doxytag: member="tbb::parallel_for" ref="g9cd1b210ceb1c040f30e390b4a21bde8" args="(const Range &amp;range, const Body &amp;body, affinity_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#g9cd1b210ceb1c040f30e390b4a21bde8">parallel_for</a> (const Range &amp;range, const Body &amp;body, <a class="el" href="a00115.html">affinity_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00115.html">affinity_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g2d317a5e0078cd193125439fed60dfdc"></a><!-- doxytag: member="tbb::parallel_for" ref="g2d317a5e0078cd193125439fed60dfdc" args="(const Range &amp;range, const Body &amp;body, const simple_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#g2d317a5e0078cd193125439fed60dfdc">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00160.html">simple_partitioner</a> &amp;partitioner, <a class="el" href="a00167.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with simple partitioner and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g1c0700e3f85e83a788ff3ede88ebb7e9"></a><!-- doxytag: member="tbb::parallel_for" ref="g1c0700e3f85e83a788ff3ede88ebb7e9" args="(const Range &amp;range, const Body &amp;body, const auto_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#g1c0700e3f85e83a788ff3ede88ebb7e9">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00120.html">auto_partitioner</a> &amp;partitioner, <a class="el" href="a00167.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00120.html">auto_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g04b4696b67370c01353ff5974c8f1196"></a><!-- doxytag: member="tbb::parallel_for" ref="g04b4696b67370c01353ff5974c8f1196" args="(const Range &amp;range, const Body &amp;body, affinity_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#g04b4696b67370c01353ff5974c8f1196">parallel_for</a> (const Range &amp;range, const Body &amp;body, <a class="el" href="a00115.html">affinity_partitioner</a> &amp;partitioner, <a class="el" href="a00167.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00115.html">affinity_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_for_each</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gbcb40499f038fd82deca88366b404790"></a><!-- doxytag: member="tbb::parallel_for_each" ref="gbcb40499f038fd82deca88366b404790" args="(InputIterator first, InputIterator last, Function f, task_group_context &amp;context)" -->
template&lt;typename InputIterator, typename Function&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Function&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#gbcb40499f038fd82deca88366b404790">parallel_for_each</a> (InputIterator first, InputIterator last, Function f, <a class="el" href="a00167.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls function f for all items from [first, last) interval using user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g85a58ff0853f129adb6f9e4355326ccc"></a><!-- doxytag: member="tbb::parallel_for_each" ref="g85a58ff0853f129adb6f9e4355326ccc" args="(InputIterator first, InputIterator last, Function f)" -->
template&lt;typename InputIterator, typename Function&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Function&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#g85a58ff0853f129adb6f9e4355326ccc">parallel_for_each</a> (InputIterator first, InputIterator last, Function f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses default context. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_invoke</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gbaadafdb93d290acec86e07fc8909c29"></a><!-- doxytag: member="tbb::parallel_invoke" ref="gbaadafdb93d290acec86e07fc8909c29" args="(F0 f0, F1 f1, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#gbaadafdb93d290acec86e07fc8909c29">parallel_invoke</a> (F0 f0, F1 f1, <a class="el" href="a00167.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes a list of tasks in parallel and waits for all tasks to complete. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g3cbf43007d0caeb4a2470265f50b25df"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g3cbf43007d0caeb4a2470265f50b25df" args="(F0 f0, F1 f1, F2 f2, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (F0 f0, F1 f1, F2 f2, <a class="el" href="a00167.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g063924a497ba64c49351e80e39bd2c17"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g063924a497ba64c49351e80e39bd2c17" args="(F0 f0, F1 f1, F2 f2, F3 f3, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2, typename F3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (F0 f0, F1 f1, F2 f2, F3 f3, <a class="el" href="a00167.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g2ca8b49b9b36515247e45ffd9c0c11cf"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g2ca8b49b9b36515247e45ffd9c0c11cf" args="(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, <a class="el" href="a00167.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g559685c3c13e103c6d570efef419c2b9"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g559685c3c13e103c6d570efef419c2b9" args="(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, <a class="el" href="a00167.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gd979d007cc4026c34691a4b38edd36af"></a><!-- doxytag: member="tbb::parallel_invoke" ref="gd979d007cc4026c34691a4b38edd36af" args="(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, <a class="el" href="a00167.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gd01a5d8f4902387d9081352e1edd1632"></a><!-- doxytag: member="tbb::parallel_invoke" ref="gd01a5d8f4902387d9081352e1edd1632" args="(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, <a class="el" href="a00167.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g0a66bfc0ac0691dfa71d230f5c8c3e96"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g0a66bfc0ac0691dfa71d230f5c8c3e96" args="(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, <a class="el" href="a00167.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g7182f6b5c88469cfc2b7c2ebbbd4a28c"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g7182f6b5c88469cfc2b7c2ebbbd4a28c" args="(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, <a class="el" href="a00167.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gb999ec5f8b7f0b68b9752f11ad39ab08"></a><!-- doxytag: member="tbb::parallel_invoke" ref="gb999ec5f8b7f0b68b9752f11ad39ab08" args="(F0 f0, F1 f1)" -->
template&lt;typename F0, typename F1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (F0 f0, F1 f1)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gb3783b5fbb1fdb4d2a6b3b4c6be8d4dd"></a><!-- doxytag: member="tbb::parallel_invoke" ref="gb3783b5fbb1fdb4d2a6b3b4c6be8d4dd" args="(F0 f0, F1 f1, F2 f2)" -->
template&lt;typename F0, typename F1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (F0 f0, F1 f1, F2 f2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g89c0569d95abd182f80acc38d0dbe2d4"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g89c0569d95abd182f80acc38d0dbe2d4" args="(F0 f0, F1 f1, F2 f2, F3 f3)" -->
template&lt;typename F0, typename F1, typename F2, typename F3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (F0 f0, F1 f1, F2 f2, F3 f3)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g3ef71e9441745fe708e66a0b817bebc7"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g3ef71e9441745fe708e66a0b817bebc7" args="(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (F0 f0, F1 f1, F2 f2, F3 f3, F4 f4)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g78fa19efd1a7cf7ffd1c23251c80b31d"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g78fa19efd1a7cf7ffd1c23251c80b31d" args="(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gab2e69dbef9b3f0e658cf4b8e574f552"></a><!-- doxytag: member="tbb::parallel_invoke" ref="gab2e69dbef9b3f0e658cf4b8e574f552" args="(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g262f0347e5690bb692b6dc26e26b9ebe"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g262f0347e5690bb692b6dc26e26b9ebe" args="(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g06a090fbd0eaaccf20e2409a2a222733"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g06a090fbd0eaaccf20e2409a2a222733" args="(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g3330e3c33053875705e19e29eda37627"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g3330e3c33053875705e19e29eda37627" args="(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9)</td></tr>

<tr><td colspan="2"><br><h2>parallel_reduce</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="range_req.html">Range</a> and <a class="el" href="parallel_reduce_body_req.html">parallel_reduce Body</a>. <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g1b3d59c5eb62683c5754db6970392fa3"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g1b3d59c5eb62683c5754db6970392fa3" args="(const Range &amp;range, Body &amp;body)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#g1b3d59c5eb62683c5754db6970392fa3">parallel_reduce</a> (const Range &amp;range, Body &amp;body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and default partitioner. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gec1b7c03f9da909bef5db12e3d41bed3"></a><!-- doxytag: member="tbb::parallel_reduce" ref="gec1b7c03f9da909bef5db12e3d41bed3" args="(const Range &amp;range, Body &amp;body, const simple_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#gec1b7c03f9da909bef5db12e3d41bed3">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00160.html">simple_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00160.html">simple_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g18a19157e6245992fc00ca0adeb7dd37"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g18a19157e6245992fc00ca0adeb7dd37" args="(const Range &amp;range, Body &amp;body, const auto_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#g18a19157e6245992fc00ca0adeb7dd37">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00120.html">auto_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00120.html">auto_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gc61e73fcc36c92d79a217fc355ff4a6b"></a><!-- doxytag: member="tbb::parallel_reduce" ref="gc61e73fcc36c92d79a217fc355ff4a6b" args="(const Range &amp;range, Body &amp;body, affinity_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#gc61e73fcc36c92d79a217fc355ff4a6b">parallel_reduce</a> (const Range &amp;range, Body &amp;body, <a class="el" href="a00115.html">affinity_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00115.html">affinity_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g45cb00c42a18e334bbde8b7535afe460"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g45cb00c42a18e334bbde8b7535afe460" args="(const Range &amp;range, Body &amp;body, const simple_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#g45cb00c42a18e334bbde8b7535afe460">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00160.html">simple_partitioner</a> &amp;partitioner, <a class="el" href="a00167.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, simple partitioner and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g1c1ea1d7c61b3c225e92c70d669a53a5"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g1c1ea1d7c61b3c225e92c70d669a53a5" args="(const Range &amp;range, Body &amp;body, const auto_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#g1c1ea1d7c61b3c225e92c70d669a53a5">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00120.html">auto_partitioner</a> &amp;partitioner, <a class="el" href="a00167.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00120.html">auto_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gd9ac3a3811060314695f33b703c6e11b"></a><!-- doxytag: member="tbb::parallel_reduce" ref="gd9ac3a3811060314695f33b703c6e11b" args="(const Range &amp;range, Body &amp;body, affinity_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#gd9ac3a3811060314695f33b703c6e11b">parallel_reduce</a> (const Range &amp;range, Body &amp;body, <a class="el" href="a00115.html">affinity_partitioner</a> &amp;partitioner, <a class="el" href="a00167.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00115.html">affinity_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gc9412e09fb01fcad8c018ea9cffb28ef"></a><!-- doxytag: member="tbb::parallel_reduce" ref="gc9412e09fb01fcad8c018ea9cffb28ef" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#gc9412e09fb01fcad8c018ea9cffb28ef">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and default partitioner. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gaddffeec0e892ac3d6fc7fc2053e1eca"></a><!-- doxytag: member="tbb::parallel_reduce" ref="gaddffeec0e892ac3d6fc7fc2053e1eca" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const simple_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#gaddffeec0e892ac3d6fc7fc2053e1eca">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00160.html">simple_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00160.html">simple_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gb175401f0729e40dd2c5860a17c14385"></a><!-- doxytag: member="tbb::parallel_reduce" ref="gb175401f0729e40dd2c5860a17c14385" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const auto_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#gb175401f0729e40dd2c5860a17c14385">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00120.html">auto_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00120.html">auto_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gb7f1f1828ae2b330ce05b8513a495154"></a><!-- doxytag: member="tbb::parallel_reduce" ref="gb7f1f1828ae2b330ce05b8513a495154" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, affinity_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#gb7f1f1828ae2b330ce05b8513a495154">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, <a class="el" href="a00115.html">affinity_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00115.html">affinity_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gfbc0cc2026d87f11a96bcd62788f5bb5"></a><!-- doxytag: member="tbb::parallel_reduce" ref="gfbc0cc2026d87f11a96bcd62788f5bb5" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const simple_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#gfbc0cc2026d87f11a96bcd62788f5bb5">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00160.html">simple_partitioner</a> &amp;partitioner, <a class="el" href="a00167.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, simple partitioner and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g630c90a399937d9d4ae70ff883186dfd"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g630c90a399937d9d4ae70ff883186dfd" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const auto_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#g630c90a399937d9d4ae70ff883186dfd">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00120.html">auto_partitioner</a> &amp;partitioner, <a class="el" href="a00167.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00120.html">auto_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g496bd7eadb3b97495ccb5655ef90319e"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g496bd7eadb3b97495ccb5655ef90319e" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, affinity_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#g496bd7eadb3b97495ccb5655ef90319e">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, <a class="el" href="a00115.html">affinity_partitioner</a> &amp;partitioner, <a class="el" href="a00167.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00115.html">affinity_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_scan</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="range_req.html">Range</a> and <a class="el" href="parallel_scan_body_req.html">parallel_scan Body</a>. <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ged143f31dd3d96ded02ab3db915b91c7"></a><!-- doxytag: member="tbb::parallel_scan" ref="ged143f31dd3d96ded02ab3db915b91c7" args="(const Range &amp;range, Body &amp;body)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#ged143f31dd3d96ded02ab3db915b91c7">parallel_scan</a> (const Range &amp;range, Body &amp;body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel prefix with default partitioner. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gc9fac8870b2e6365fb337014404529df"></a><!-- doxytag: member="tbb::parallel_scan" ref="gc9fac8870b2e6365fb337014404529df" args="(const Range &amp;range, Body &amp;body, const simple_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#gc9fac8870b2e6365fb337014404529df">parallel_scan</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00160.html">simple_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel prefix with <a class="el" href="a00160.html">simple_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g62fde400a37bbca1a2fddc8e3d22f556"></a><!-- doxytag: member="tbb::parallel_scan" ref="g62fde400a37bbca1a2fddc8e3d22f556" args="(const Range &amp;range, Body &amp;body, const auto_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#g62fde400a37bbca1a2fddc8e3d22f556">parallel_scan</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00120.html">auto_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel prefix with <a class="el" href="a00120.html">auto_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gb7451aa58925fb7bb579b367c4ba3500"></a><!-- doxytag: member="tbb::parallel_scan" ref="gb7451aa58925fb7bb579b367c4ba3500" args="(const Range &amp;range, Body &amp;body, const simple_partitioner &amp;partitioner, tbb::task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#gb7451aa58925fb7bb579b367c4ba3500">parallel_scan</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00160.html">simple_partitioner</a> &amp;partitioner, <a class="el" href="a00167.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel prefix with <a class="el" href="a00160.html">simple_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g40a7c46037dbafa74fce7a91cc60d9d7"></a><!-- doxytag: member="tbb::parallel_scan" ref="g40a7c46037dbafa74fce7a91cc60d9d7" args="(const Range &amp;range, Body &amp;body, const auto_partitioner &amp;partitioner, tbb::task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#g40a7c46037dbafa74fce7a91cc60d9d7">parallel_scan</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00120.html">auto_partitioner</a> &amp;partitioner, <a class="el" href="a00167.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel prefix with <a class="el" href="a00120.html">auto_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g83716e2b2926c1fc225802aa309fd2bf"></a><!-- doxytag: member="tbb::parallel_scan" ref="g83716e2b2926c1fc225802aa309fd2bf" args="(const Range &amp;range, Body &amp;body, tbb::task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#g83716e2b2926c1fc225802aa309fd2bf">parallel_scan</a> (const Range &amp;range, Body &amp;body, <a class="el" href="a00167.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel prefix with default partitioner and user-supplied context. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_sort</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="parallel_sort_iter_req.html">iterators for parallel_sort</a>. <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename RandomAccessIterator, typename Compare&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#g49edcf9447cd91a9527a3f8e8512b7aa">parallel_sort</a> (RandomAccessIterator begin, RandomAccessIterator end, const Compare &amp;comp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the data in [begin,end) using the given comparator.  <a href="a00233.html#g49edcf9447cd91a9527a3f8e8512b7aa"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g16c3eb77d0e530834c51ce3857f01012"></a><!-- doxytag: member="tbb::parallel_sort" ref="g16c3eb77d0e530834c51ce3857f01012" args="(RandomAccessIterator begin, RandomAccessIterator end)" -->
template&lt;typename RandomAccessIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#g16c3eb77d0e530834c51ce3857f01012">parallel_sort</a> (RandomAccessIterator begin, RandomAccessIterator end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the data in [begin,end) with a default comparator <code>std::less&lt;RandomAccessIterator&gt;</code>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gc7576f82fdedc8a701a6c17ad9415926"></a><!-- doxytag: member="tbb::parallel_sort" ref="gc7576f82fdedc8a701a6c17ad9415926" args="(T *begin, T *end)" -->
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00233.html#gc7576f82fdedc8a701a6c17ad9415926">parallel_sort</a> (T *begin, T *end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the data in the range <code></code>[begin,end) with a default comparator <code>std::less&lt;T&gt;</code>. <br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7fdc2b067a243747d4c3dfe6f3d28476"></a><!-- doxytag: member="tbb::spin_rw_mutex" ref="7fdc2b067a243747d4c3dfe6f3d28476" args="" -->
typedef <a class="el" href="a00163.html">spin_rw_mutex_v3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>spin_rw_mutex</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3d457eb737199125df5ab0cf2f44094"></a><!-- doxytag: member="tbb::stack_size_type" ref="a3d457eb737199125df5ab0cf2f44094" args="" -->
typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>stack_size_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ceb89493291d4b03ce5f062fbaac0653"></a><!-- doxytag: member="tbb::task_scheduler_observer" ref="ceb89493291d4b03ce5f062fbaac0653" args="" -->
typedef internal::task_scheduler_observer_v3&nbsp;</td><td class="memItemRight" valign="bottom"><b>task_scheduler_observer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ed375248ff6019a70ca0f9da528e5d0b"></a><!-- doxytag: member="tbb::assertion_handler_type" ref="ed375248ff6019a70ca0f9da528e5d0b" args="(const char *filename, int line, const char *expression, const char *comment)" -->
typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00229.html#ed375248ff6019a70ca0f9da528e5d0b">assertion_handler_type</a> (const char *filename, int line, const char *expression, const char *comment)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type for an assertion handler. <br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00229.html#a8686246bb5d3664bd07563749970fef">memory_semantics</a> { <a class="el" href="a00229.html#a8686246bb5d3664bd07563749970fefc6db01678b1749dff7554688d079520c">__TBB_full_fence</a>, 
<a class="el" href="a00229.html#a8686246bb5d3664bd07563749970fef5f1fafe8d229d348ff91d937f64e79c7">acquire</a>, 
<a class="el" href="a00229.html#a8686246bb5d3664bd07563749970fefaa1fa107db0245c41fb109d976ae8d70">release</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies memory fencing.  <a href="a00229.html#a8686246bb5d3664bd07563749970fef">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00229.html#a8622ae61b7e7737dac26542e181178e">ets_key_usage_type</a> { <b>ets_key_per_instance</b>, 
<b>ets_no_key</b>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">enum for selecting between single key and key-per-instance versions <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>task_group_status</b> { <b>not_complete</b>, 
<b>complete</b>, 
<b>canceled</b>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2e067bc86f20023cf3034f2ac310927b"></a><!-- doxytag: member="tbb::__TBB_DECL_ATOMIC" ref="2e067bc86f20023cf3034f2ac310927b" args="(__TBB_LONG_LONG) __TBB_DECL_ATOMIC(unsigned __TBB_LONG_LONG) __TBB_DECL_ATOMIC(long) __TBB_DECL_ATOMIC(unsigned long) __TBB_DECL_ATOMIC_ALT(unsigned" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>__TBB_DECL_ATOMIC</b> (__TBB_LONG_LONG) __TBB_DECL_ATOMIC(unsigned __TBB_LONG_LONG) __TBB_DECL_ATOMIC(long) __TBB_DECL_ATOMIC(unsigned long) __TBB_DECL_ATOMIC_ALT(unsigned</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ad165cf61abbe349d413df2589679add"></a><!-- doxytag: member="tbb::__TBB_DECL_ATOMIC_ALT" ref="ad165cf61abbe349d413df2589679add" args="(int, ptrdiff_t) __TBB_DECL_ATOMIC(unsigned) __TBB_DECL_ATOMIC(int) __TBB_DECL_ATOMIC(unsigned short) __TBB_DECL_ATOMIC(short) __TBB_DECL_ATOMIC(char) __TBB_DECL_ATOMIC(signed char) __TBB_DECL_ATOMIC(unsigned char) __TBB_DECL_ATOMIC(wchar_t) template&lt; typename T &gt; struct atomic&lt; T * &gt;" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00229.html#ad165cf61abbe349d413df2589679add">__TBB_DECL_ATOMIC_ALT</a> (int, ptrdiff_t) __TBB_DECL_ATOMIC(unsigned) __TBB_DECL_ATOMIC(int) __TBB_DECL_ATOMIC(unsigned short) __TBB_DECL_ATOMIC(short) __TBB_DECL_ATOMIC(char) __TBB_DECL_ATOMIC(signed char) __TBB_DECL_ATOMIC(unsigned char) __TBB_DECL_ATOMIC(wchar_t) template&lt; typename T &gt; struct <a class="el" href="a00117.html">atomic</a>&lt; T * &gt;</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for atomic&lt;T*&gt; with arithmetic and operator-&gt;. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="7af9509624a62ea848afe775f892ed12"></a><!-- doxytag: member="tbb::operator==" ref="7af9509624a62ea848afe775f892ed12" args="(const cache_aligned_allocator&lt; T &gt; &amp;, const cache_aligned_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00125.html">cache_aligned_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00125.html">cache_aligned_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="426abbf5243087148f5e3767e68c286b"></a><!-- doxytag: member="tbb::operator!=" ref="426abbf5243087148f5e3767e68c286b" args="(const cache_aligned_allocator&lt; T &gt; &amp;, const cache_aligned_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00125.html">cache_aligned_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00125.html">cache_aligned_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="2babc190640003767a3049a4d3c5ee35"></a><!-- doxytag: member="tbb::tbb_hasher" ref="2babc190640003767a3049a4d3c5ee35" args="(const T &amp;t)" -->
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00229.html#2babc190640003767a3049a4d3c5ee35">tbb_hasher</a> (const T &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hasher functions. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="3835d3fac75c3963cbfc312c67ddbba3"></a><!-- doxytag: member="tbb::tbb_hasher" ref="3835d3fac75c3963cbfc312c67ddbba3" args="(P *ptr)" -->
template&lt;typename P&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>tbb_hasher</b> (P *ptr)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="057a50bf70efdeabd5756f8698015b0f"></a><!-- doxytag: member="tbb::tbb_hasher" ref="057a50bf70efdeabd5756f8698015b0f" args="(const std::basic_string&lt; E, S, A &gt; &amp;s)" -->
template&lt;typename E, typename S, typename A&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>tbb_hasher</b> (const std::basic_string&lt; E, S, A &gt; &amp;s)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="77bb4a96964d4d9cb058a9791bac9b0d"></a><!-- doxytag: member="tbb::tbb_hasher" ref="77bb4a96964d4d9cb058a9791bac9b0d" args="(const std::pair&lt; F, S &gt; &amp;p)" -->
template&lt;typename F, typename S&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>tbb_hasher</b> (const std::pair&lt; F, S &gt; &amp;p)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="f3609fc523a99c101572fdc68f918d66"></a><!-- doxytag: member="tbb::operator==" ref="f3609fc523a99c101572fdc68f918d66" args="(const concurrent_hash_map&lt; Key, T, HashCompare, A1 &gt; &amp;a, const concurrent_hash_map&lt; Key, T, HashCompare, A2 &gt; &amp;b)" -->
template&lt;typename Key, typename T, typename HashCompare, typename A1, typename A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00130.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A1 &gt; &amp;a, const <a class="el" href="a00130.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="2da30ff86b9a39722f45bc35e1c6934d"></a><!-- doxytag: member="tbb::operator!=" ref="2da30ff86b9a39722f45bc35e1c6934d" args="(const concurrent_hash_map&lt; Key, T, HashCompare, A1 &gt; &amp;a, const concurrent_hash_map&lt; Key, T, HashCompare, A2 &gt; &amp;b)" -->
template&lt;typename Key, typename T, typename HashCompare, typename A1, typename A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00130.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A1 &gt; &amp;a, const <a class="el" href="a00130.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="817c20df80fe1a933a8557eb76113e24"></a><!-- doxytag: member="tbb::swap" ref="817c20df80fe1a933a8557eb76113e24" args="(concurrent_hash_map&lt; Key, T, HashCompare, A &gt; &amp;a, concurrent_hash_map&lt; Key, T, HashCompare, A &gt; &amp;b)" -->
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="a00130.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt; &amp;a, <a class="el" href="a00130.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="11419db87ac98110907dda08a24f0949"></a><!-- doxytag: member="tbb::operator==" ref="11419db87ac98110907dda08a24f0949" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00136.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00136.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="aa9e09f2e9154ffd6658fad8355fb491"></a><!-- doxytag: member="tbb::operator!=" ref="aa9e09f2e9154ffd6658fad8355fb491" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00136.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00136.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="33267dd805415351956d45b4b5347190"></a><!-- doxytag: member="tbb::operator&lt;" ref="33267dd805415351956d45b4b5347190" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="a00136.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00136.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="14e2968ab20cb714bef1f0352fc152f0"></a><!-- doxytag: member="tbb::operator&gt;" ref="14e2968ab20cb714bef1f0352fc152f0" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="a00136.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00136.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="0042a36a670a397fb52e713edbaecd0e"></a><!-- doxytag: member="tbb::operator&lt;=" ref="0042a36a670a397fb52e713edbaecd0e" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="a00136.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00136.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="f70eb1d931473b69ba4bcf93af8baa33"></a><!-- doxytag: member="tbb::operator&gt;=" ref="f70eb1d931473b69ba4bcf93af8baa33" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="a00136.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00136.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="4a3897ea8d8a48e885d764bd7d370d50"></a><!-- doxytag: member="tbb::swap" ref="4a3897ea8d8a48e885d764bd7d370d50" args="(concurrent_vector&lt; T, A &gt; &amp;a, concurrent_vector&lt; T, A &gt; &amp;b)" -->
template&lt;typename T, class A&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="a00136.html">concurrent_vector</a>&lt; T, A &gt; &amp;a, <a class="el" href="a00136.html">concurrent_vector</a>&lt; T, A &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="cac990ecc7b1d2088bf5d047801d63a5"></a><!-- doxytag: member="tbb::flatten2d" ref="cac990ecc7b1d2088bf5d047801d63a5" args="(const Container &amp;c, const typename Container::const_iterator b, const typename Container::const_iterator e)" -->
template&lt;typename Container&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">flattened2d&lt; Container &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>flatten2d</b> (const Container &amp;c, const typename Container::const_iterator b, const typename Container::const_iterator e)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="b327db9f1ccb9bdfcdbacbf07fac6d10"></a><!-- doxytag: member="tbb::flatten2d" ref="b327db9f1ccb9bdfcdbacbf07fac6d10" args="(const Container &amp;c)" -->
template&lt;typename Container&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">flattened2d&lt; Container &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>flatten2d</b> (const Container &amp;c)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="906ebb461ecb0446989739fd0399e4b8"></a><!-- doxytag: member="tbb::operator==" ref="906ebb461ecb0446989739fd0399e4b8" args="(const scalable_allocator&lt; T &gt; &amp;, const scalable_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00158.html">scalable_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00158.html">scalable_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a92757aca0a69082eb8dc223eb257433"></a><!-- doxytag: member="tbb::operator!=" ref="a92757aca0a69082eb8dc223eb257433" args="(const scalable_allocator&lt; T &gt; &amp;, const scalable_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00158.html">scalable_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00158.html">scalable_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7e2f5baabe173fbf48e94fb9058f1b41"></a><!-- doxytag: member="tbb::is_current_task_group_canceling" ref="7e2f5baabe173fbf48e94fb9058f1b41" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>is_current_task_group_canceling</b> ()</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="c8a46d6c0fe474eb399d0d09c27a4685"></a><!-- doxytag: member="tbb::operator==" ref="c8a46d6c0fe474eb399d0d09c27a4685" args="(const tbb_allocator&lt; T &gt; &amp;, const tbb_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00170.html">tbb_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00170.html">tbb_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="3d9665c21c894f06f1614947103dc9d6"></a><!-- doxytag: member="tbb::operator!=" ref="3d9665c21c894f06f1614947103dc9d6" args="(const tbb_allocator&lt; T &gt; &amp;, const tbb_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00170.html">tbb_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00170.html">tbb_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="b64fb7e52f0049b5a103cbb6fb5814f0"></a><!-- doxytag: member="tbb::operator==" ref="b64fb7e52f0049b5a103cbb6fb5814f0" args="(const zero_allocator&lt; T1, B1 &gt; &amp;a, const zero_allocator&lt; T2, B2 &gt; &amp;b)" -->
template&lt;typename T1, template&lt; typename X1 &gt; class B1, typename T2, template&lt; typename X2 &gt; class B2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00179.html">zero_allocator</a>&lt; T1, B1 &gt; &amp;a, const <a class="el" href="a00179.html">zero_allocator</a>&lt; T2, B2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ae43b5151d0220fe3ade0b447cd64f0d"></a><!-- doxytag: member="tbb::operator!=" ref="ae43b5151d0220fe3ade0b447cd64f0d" args="(const zero_allocator&lt; T1, B1 &gt; &amp;a, const zero_allocator&lt; T2, B2 &gt; &amp;b)" -->
template&lt;typename T1, template&lt; typename X1 &gt; class B1, typename T2, template&lt; typename X2 &gt; class B2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00179.html">zero_allocator</a>&lt; T1, B1 &gt; &amp;a, const <a class="el" href="a00179.html">zero_allocator</a>&lt; T2, B2 &gt; &amp;b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="823fa1c15dd829d1d9167157450ddcd9"></a><!-- doxytag: member="tbb::set_assertion_handler" ref="823fa1c15dd829d1d9167157450ddcd9" args="(assertion_handler_type new_handler)" -->
<a class="el" href="a00229.html#ed375248ff6019a70ca0f9da528e5d0b">assertion_handler_type</a> __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00229.html#823fa1c15dd829d1d9167157450ddcd9">set_assertion_handler</a> (<a class="el" href="a00229.html#ed375248ff6019a70ca0f9da528e5d0b">assertion_handler_type</a> new_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set assertion handler and return previous value of it. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00229.html#3d1252787be39b4aef311f1cadaff9e8">assertion_failure</a> (const char *filename, int line, const char *expression, const char *comment)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process an assertion failure.  <a href="#3d1252787be39b4aef311f1cadaff9e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00229.html#a6858b22e90041c9c4669674ff39b056">TBB_runtime_interface_version</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function returns the interface version of the TBB shared library being used.  <a href="#a6858b22e90041c9c4669674ff39b056"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6a42aa5dbcf06ba86c71efb73d8311c3"></a><!-- doxytag: member="tbb::operator-" ref="6a42aa5dbcf06ba86c71efb73d8311c3" args="(const tick_count &amp;t1, const tick_count &amp;t0)" -->
<a class="el" href="a00177.html">tick_count::interval_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="a00176.html">tick_count</a> &amp;t1, const <a class="el" href="a00176.html">tick_count</a> &amp;t0)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6902d551186a654ffbf88582d4a0bdfa"></a><!-- doxytag: member="tbb::hash_multiplier" ref="6902d551186a654ffbf88582d4a0bdfa" args="" -->
static const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00229.html#6902d551186a654ffbf88582d4a0bdfa">hash_multiplier</a> = sizeof(size_t)==4? 2654435769U : 11400714819323198485ULL</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hash multiplier. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The namespace tbb contains all components of the library. <hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="a8686246bb5d3664bd07563749970fef"></a><!-- doxytag: member="tbb::memory_semantics" ref="a8686246bb5d3664bd07563749970fef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00229.html#a8686246bb5d3664bd07563749970fef">tbb::memory_semantics</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specifies memory fencing. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="a8686246bb5d3664bd07563749970fefc6db01678b1749dff7554688d079520c"></a><!-- doxytag: member="__TBB_full_fence" ref="a8686246bb5d3664bd07563749970fefc6db01678b1749dff7554688d079520c" args="" -->__TBB_full_fence</em>&nbsp;</td><td>
For internal use only. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="a8686246bb5d3664bd07563749970fef5f1fafe8d229d348ff91d937f64e79c7"></a><!-- doxytag: member="acquire" ref="a8686246bb5d3664bd07563749970fef5f1fafe8d229d348ff91d937f64e79c7" args="" -->acquire</em>&nbsp;</td><td>
Acquire fence. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="a8686246bb5d3664bd07563749970fefaa1fa107db0245c41fb109d976ae8d70"></a><!-- doxytag: member="release" ref="a8686246bb5d3664bd07563749970fefaa1fa107db0245c41fb109d976ae8d70" args="" -->release</em>&nbsp;</td><td>
Release fence. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="3d1252787be39b4aef311f1cadaff9e8"></a><!-- doxytag: member="tbb::assertion_failure" ref="3d1252787be39b4aef311f1cadaff9e8" args="(const char *filename, int line, const char *expression, const char *comment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __TBB_EXPORTED_FUNC tbb::assertion_failure           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>comment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Process an assertion failure. 
<p>
Normally called from __TBB_ASSERT macro. If assertion handler is null, print message for assertion failure and abort. Otherwise call the assertion handler. 
</div>
</div><p>
<a class="anchor" name="a6858b22e90041c9c4669674ff39b056"></a><!-- doxytag: member="tbb::TBB_runtime_interface_version" ref="a6858b22e90041c9c4669674ff39b056" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __TBB_EXPORTED_FUNC tbb::TBB_runtime_interface_version           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function returns the interface version of the TBB shared library being used. 
<p>
The version it returns is determined at runtime, not at compile/link time. So it can be different than the value of TBB_INTERFACE_VERSION obtained at compile time. 
</div>
</div><p>
<hr>
<p></p>
Copyright &copy; 2005-2009 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
